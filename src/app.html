<html>
  <head>
    <title>Note</title>
    <meta charset="UTF-8">
    <meta name="description" content="Web app for taking notes with autosave feature">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
    <style>
      /* Style the container element */
      .container {
        display: flex;
        flex-direction: column;
        width: 100%;
        min-height: 100vh;
        background-color: rgb(248,248,248); /*HEX: f8f8f8*/
        color: rgb(51,51,51); /*HEX: 333*/
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px 20px 0 20px;
        box-sizing: border-box;
      }

      /* Style the switch element */
      .switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 20px;
      }

      /* Style the switch lever */
      .switch .slider {
        position: absolute;
        cursor: pointer;
        width: 55px;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgb(204,204,204); /*HEX: ccc*/
        transition: .4s;
        border-radius: 12px;
      }

      .switch .slider:before {
        content: "";
        position: absolute;
        width: 36px;
        height: 20px;
        background-color: white;
        transition: .4s;
        border-radius: 12px;
      }

      /* Style the switch when checked */
      .switch input[type="checkbox"]:checked + .slider:before {
        transform: translateX(20px);
      }

      /* Style the header element */
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      /* Style the note title input */
      .header input[type="text"] {
        width: 100%;
        margin-right: 15px;
        box-sizing: border-box;
      }

      /* Style the text area */
      .content {
        flex: 1;
      }

      .content textarea {
        width: 100%;
        height: calc(100vh - 100px);
        resize: none;
      }

      .header input[type="text"],
      .content textarea {
        padding: 10px;
        font-size: 16px;
        border: 1px solid rgb(204,204,204); /*HEX: ccc*/
        border-radius: 4px;
        outline: none;
      }

      .header input[type="text"]:focus,
      .content textarea:focus {
        border-color: rgb(153,153,153); /*HEX: 999*/
      }

      /* Scrollbar styling */
      .content textarea::-webkit-scrollbar {
          width: 14px;
      }
      .content textarea::-webkit-scrollbar-track {
          background: transparent;
          border: none;
      }
      .content textarea::-webkit-scrollbar-thumb {
          background-color: rgba(31, 31, 31, .16);
          background-clip: padding-box;
          border: 3px solid transparent;
          border-radius: 8px;
          box-shadow: none;
          height: 64px;
          cursor: default;
      }
      .content textarea::-webkit-scrollbar-thumb:hover {
          background-color: rgba(31, 31, 31, .24);
      }

      /* Style the footer */
      .footer {
          display: flex;
          justify-content: space-between;
          align-items: center;
          font-size: 12px;
          height: 20px;
          color: rgb(136,136,136); /*HEX: 888*/
      }
      .footer-left {
          flex: 1;
          text-align: left;
      }
      .footer-right {
          flex: 1;
          text-align: right;
      }

      /* Dark mode styles */
      .container.dark {
        background-color: rgb(51,51,51); /*HEX: 333*/
      }

      .container.dark input[type="text"],
      .container.dark textarea {
        background-color: rgb(68,68,68); /*HEX: 444*/
        border-color: rgb(85,85,85); /*HEX: 555*/
        color: rgb(238,238,238); /*HEX: eee*/
      }

      .container.dark input[type="text"]:focus,
      .container.dark textarea:focus {
        border-color:  rgb(119,119,119); /*HEX: 777*/
      }

      .container.dark textarea::-webkit-scrollbar-thumb {
          background-color: rgba(227, 227, 227, .16);
      }
      .container.dark textarea::-webkit-scrollbar-thumb:hover {
          background-color: rgba(227, 227, 227, .24);
      }

      .container.dark .switch .slider {
        background-color: rgb(85,85,85); /*HEX: 555*/
      }

      .container.dark .switch input[type="checkbox"]:checked + .slider {
        background-color: rgb(0,123,255); /*HEX: 007bff*/
      }

      /* Color transition time */
      .container, textarea, input {
        transition: .2s;
      }

      /* document reset margins */
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <input type="text" id="note-title" placeholder="Note Title">
        <label class="switch" title="Light / Dark Theme Switcher">
          <input type="checkbox" id="toggle">
          <span class="slider"></span>
        </label>
      </div>
      <div class="content">
        <textarea id="note-content" placeholder="Some text..."></textarea>
      </div>
      <footer class="footer">
        <span class="footer-left">Note ID: <span id="note-id"></span></span>
        <span class="footer-right">Updated at: <span id="time-updated-at"></span></span>
      </footer>
    </div>
    <script>
      const isCompressHashedDataGlobal = true;
      const hashDataDelimiterSymbol = ',';
      const hashDataWrapSymbol = '|';

      const body = document.body;
      const container = document.querySelector('.container');
      const toggle = document.getElementById('toggle');
      const noteTitle = document.getElementById('note-title');
      const noteContent = document.getElementById('note-content');
      const noteIdSpan = document.getElementById('note-id');
      const noteUpdatedAtSpan = document.getElementById('time-updated-at');

      const helper = {
        _noteId: null,
        _wrapSymbol: hashDataWrapSymbol,

        get noteId() {
          if (Object.is(this._noteId, null)) {
            this.generateId();
          }

          return this._noteId;
        },

        set noteId(value) {
          this._noteId = this.trimValue(value);
        },

        generateId() {
          this._noteId = Date.now().toString(); // timestamp, equal to date created
          this.renderId();
        },

        renderId() {
          renderNoteId(this._noteId);
        },

        wrapValue(value) {
          return `${this._wrapSymbol}${value}${this._wrapSymbol}`;
        },

        trimValue(value) {
          return String(value).replaceAll(this._wrapSymbol, '');
        },
      };

      async function zipData(data) {
        // SRC: https://dev.to/ternentdotdev/json-compression-in-the-browser-with-gzip-and-the-compression-streams-api-4135
        // Convert text to Stream
        const stream = new Blob([data], { type: 'text/plain' }).stream();
        // gzip stream
        const compressedStream = stream.pipeThrough(new CompressionStream('gzip'));
        // create Response
        const compressedResponse = await new Response(compressedStream);
        // Get response Blob
        const compressedBlob = await compressedResponse.blob();
        // Get the ArrayBuffer
        const buffer = await compressedBlob.arrayBuffer();

        // convert ArrayBuffer to base64 encoded string
        const compressedBase64 = btoa(
          String.fromCharCode(
            ...new Uint8Array(buffer)
          )
        );

        return compressedBase64;
      }

      async function unzipData(compressedBase64) {
        const binaryString = atob(compressedBase64);
        const buffer = new Uint8Array(binaryString.length);

        for (let i = 0; i < binaryString.length; i++) {
          buffer[i] = binaryString.charCodeAt(i);
        }

        // base64 encoding to Blob
        const stream = new Blob([buffer], { type: 'application/octet-stream' }).stream();
        // piping our data through the gzip DecompressionStream
        const decompressedStream = stream.pipeThrough(new DecompressionStream('gzip'));
        // create Response
        const decompressedResponse = await new Response(decompressedStream);
        // read decompressed stream as blob
        const decompressedBlob = await decompressedResponse.blob();
        // get the content back in string format
        const decompressedData = await decompressedBlob.text();

        return decompressedData;
      }

      async function serializeDataToHash() {
        const isThemeDark = toggle.checked ? 1 : 0;
        const updatedAt = Date.now();

        let encodedTitle = '';
        let encodedContent = '';
        let isDataZipped = 0;

        if (isCompressHashedDataGlobal) {
          try {
            encodedTitle = await zipData(encodeURIComponent(noteTitle.value));
            encodedContent = await zipData(encodeURIComponent(noteContent.value));
            isDataZipped = 1;
          } catch (error) {
            console.warn('Data compression not supported. Storing data unzipped. ', error);
          }
        }
        
        if (!isDataZipped) {
          encodedTitle = btoa(encodeURIComponent(noteTitle.value));
          encodedContent = btoa(encodeURIComponent(noteContent.value));
        }
        
        writeDataToHash({
          "title": encodedTitle,
          "content": encodedContent,
          "theme": isThemeDark,
          "zipped": isDataZipped,
          "id": helper.wrapValue(helper.noteId),
          "updated": updatedAt,
        });
        
        renderUpdatedAtDate(updatedAt);
      }
      
      async function deserializeAndRenderData(data) {
        // Decode and apply data
        const isThemeDark = parseInt(data["theme"], 10);
        const isDataZipped = parseInt(data["zipped"], 10);

        helper.noteId = data["id"];

        let decodedTitle = '';
        let decodedContent = '';

        if (isDataZipped) {
          decodedTitle = await unzipData(data["title"]);
          decodedContent = await unzipData(data["content"]);
        } else {
          decodedTitle = atob(data["title"]);
          decodedContent = atob(data["content"]);
        }

        toggle.checked = Boolean(isThemeDark);
        noteTitle.value = decodeURIComponent(decodedTitle);
        noteContent.value = decodeURIComponent(decodedContent);

        if (toggle.checked) {
          darkThemeSwitch();
        }
      }

      function readStoredDataInHash() {
        // Get hash data from URL
        const hash = window.location.hash.substring(1); // Remove leading hash symbol

        if (!hash) {
          return null; // No hash data present
        }

        return mapStructure(hash.split(hashDataDelimiterSymbol));
      }

      function writeDataToHash(data) {
        const hashSymbol = String.fromCharCode(35);

        const hashData = mapStructure(data).join(hashDataDelimiterSymbol);

        history.replaceState(undefined, '', hashSymbol + hashData);
      }

      /**
       * return: Array | Object | null
       */
      function mapStructure(data) {
        const keysOrder = [
          "theme",
          "zipped",
          "id",
          "updated",
          "title",
          "content",
        ];

        let mappedData = null;

        if (Array.isArray(data)) {
          // convert number keys to literal keys
          if (data.length === keysOrder.length) {
            mappedData = {};
            keysOrder.forEach((key, index) => {
              mappedData[key] = data[index];
            });
          }
        } else if (data instanceof Object) {
          // convert literal keys to number keys
          if (Object.keys(data).length === keysOrder.length) {
            mappedData = [];
            Object.entries(data).forEach(([key, value]) => {
              const index = keysOrder.indexOf(key);
              mappedData[index] = value;
            });
          }
        }

        return mappedData;
      }
      
      // Debounce function
      let timeoutId = null; // Variable to store the timeout reference
      function debounce(func, delay) {
        return function (...args) {
          clearTimeout(timeoutId); // Clear any existing timeout
          timeoutId = setTimeout(() => {
            func.apply(this, args); // Call the function with arguments after delay
          }, delay);
        };
      }
      
      function renderNoteId(value) {
        if (value) {
          noteIdSpan.innerHTML = value;
        }
      }
      
      function renderUpdatedAtDate(value) {
        if (value) {
          noteUpdatedAtSpan.innerHTML = (new Date(parseInt(value, 10))).toLocaleString('en-CA', { hour12: false });
        }
      }

      function updateDocumentTitle() {
        document.title = noteTitle.value || 'Note';
      }

      function darkThemeSwitch() {
        ['dark'].map(v => container.classList.toggle(v, toggle.checked));
      }

      function applySystemTheme() {
        // Set theme based on browser/system preference
        const prefersDark = matchMedia('(prefers-color-scheme: dark)').matches;
        toggle.checked = prefersDark;
        darkThemeSwitch();
      }

      /**
       * Run the App
       */
      (function(){
        const storedData = readStoredDataInHash();

        if (storedData) {
          // Apply initial data from hash on page load
          deserializeAndRenderData(storedData).then(updateDocumentTitle);
          // render footer block
          renderNoteId(helper.noteId);
          renderUpdatedAtDate(storedData["updated"]);
        } else {
          // in case if this is the first launch of the app (if hash is absent)
          applySystemTheme();
        }

        // Debounced version with delay in milliseconds
        const delayedSerializeDataToHash = debounce(serializeDataToHash, 3000);
        // Bind DOM Events
        toggle.addEventListener('change', delayedSerializeDataToHash);
        noteTitle.addEventListener('input', delayedSerializeDataToHash);
        noteContent.addEventListener('input', delayedSerializeDataToHash);

        toggle.addEventListener('change', darkThemeSwitch);
        noteTitle.addEventListener('input', updateDocumentTitle);
      })();
    </script>
  </body>
</html>

<html>
  <head>
    <title>Note</title>
    <meta charset="UTF-8">
    <meta name="description" content=" Web app for taking notes with autosave feature">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
    <style>
      /* Style the container element */
      .container {
        display: flex;
        flex-direction: column;
        width: 100%;
        min-height: 100vh;
        background-color: rgb(248,248,248);/*HEX: f8f8f8*/
        color: rgb(51,51,51);/*HEX: 333*/
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px 20px 0 20px;
        box-sizing: border-box;
      }

      /* Style the switch element */
      .switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 20px;
      }

      /* Style the switch lever */
      .switch .slider {
        position: absolute;
        cursor: pointer;
        width: 55px;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgb(204,204,204);/*HEX: ccc*/
        transition: .4s;
        border-radius: 12px;
      }

      .switch .slider:before {
        content: "";
        position: absolute;
        width: 36px;
        height: 20px;
        background-color: white;
        transition: .4s;
        border-radius: 12px;
      }

      /* Style the switch when checked */
      .switch input[type="checkbox"]:checked + .slider:before {
        transform: translateX(20px);
      }

      /* Style the header element */
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      /* Style the note title input */
      .header input[type="text"] {
        width: 100%;
        margin-right: 15px;
        box-sizing: border-box;
      }

      /* Style the text area */
      .content {
        flex: 1;
      }

      .content textarea {
        width: 100%;
        height: calc(100vh - 100px);
        resize: none;
      }
      
      .header input[type="text"],
      .content textarea {
        padding: 10px;
        font-size: 16px;
        border: 1px solid rgb(204,204,204);/*HEX: ccc*/
        border-radius: 4px;
        outline: none;
      }
      
      .header input[type="text"]:focus,
      .content textarea:focus {
        border-color: rgb(153,153,153);/*HEX: 999*/
      }
      
      /* Scrollbar styling */
      .content textarea::-webkit-scrollbar {
          width: 14px;
      }
      .content textarea::-webkit-scrollbar-track {
          background: transparent;
          border: none;
      }
      .content textarea::-webkit-scrollbar-thumb {
          background-color: rgba(31, 31, 31, .16);
          background-clip: padding-box;
          border: 3px solid transparent;
          border-radius: 8px;
          box-shadow: none;
          height: 64px;
          cursor: default;
      }
      .content textarea::-webkit-scrollbar-thumb:hover {
          background-color: rgba(31, 31, 31, .24);
      }
      
      /* Style the footer */
      .footer {
          display: flex;
          justify-content: space-between;
          align-items: center;
          font-size: 12px;
          height: 20px;
          color: rgb(136,136,136);/*HEX: 888*/
      }
      .footer-left {
          flex: 1;
          text-align: left;
      }
      .footer-right {
          flex: 1;
          text-align: right;
      }

      /* Dark mode styles */
      .container.dark {
        background-color: rgb(51,51,51);/*HEX: 333*/
      }

      .container.dark input[type="text"],
      .container.dark textarea {
        background-color: rgb(68,68,68);/*HEX: 444*/
        border-color: rgb(85,85,85);/*HEX: 555*/
        color: rgb(238,238,238);/*HEX: eee*/
      }
      
      .container.dark input[type="text"]:focus,
      .container.dark textarea:focus {
        border-color:  rgb(119,119,119);/*HEX: 777*/
      }
      
      .container.dark textarea::-webkit-scrollbar-thumb {
          background-color: rgba(227, 227, 227, .16);
      }
      .container.dark textarea::-webkit-scrollbar-thumb:hover {
          background-color: rgba(227, 227, 227, .24);
      }

      .container.dark .switch .slider {
        background-color: rgb(85,85,85);/*HEX: 555*/
      }

      .container.dark .switch input[type="checkbox"]:checked + .slider {
        background-color: rgb(0,123,255);/*HEX: 007bff*/
      }

      /* Color transition time */
      .light, .dark, textarea, input {
        transition: .2s;
      }

      /* document reset margins */
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <div class="container light">
      <div class="header">
        <input type="text" id="note-title" placeholder="Note Title">
        <label class="switch" title="Light / Dark Theme Switcher">
          <input type="checkbox" id="toggle">
          <span class="slider"></span>
        </label>
      </div>
      <div class="content">
        <textarea id="note-content" placeholder="Some text..."></textarea>
      </div>
      <footer class="footer">
        <span class="footer-left">Note ID: <span id="note-id"></span></span>
        <span class="footer-right">Updated at: <span id="time-updated-at"></span></span>
      </footer>
    </div>
    <script>
      const isCompressHashedDataGlobal = true;
      const hashDataSeparatorSymbol = ',';
      const body = document.body;
      const container = document.querySelector('.container');
      const toggle = document.getElementById('toggle');
      const noteTitle = document.getElementById('note-title');
      const noteContent = document.getElementById('note-content');
      const noteUUID = document.getElementById('note-id');
      const noteUpdatedAt = document.getElementById('time-updated-at');
      
      let uuid = null;
      let updatedAt = null;
      
      toggle.addEventListener('change', function() {
        ['dark'].map( v => container.classList.toggle(v, this.checked) );
      });
      
      noteTitle.addEventListener('input', function() {
        document.title = this.value || 'Note...';
      });
      
      function renderUUID() {
        if (uuid) {
          noteUUID.innerHTML = uuid;
        }
      }
      
      function renderUpdatedAt() {
        if (updatedAt) {
          noteUpdatedAt.innerHTML = (new Date(updatedAt)).toLocaleString('en-CA', { hour12: false });
        }
      }
      
      async function zipData(data) {
        // SRC: https://dev.to/ternentdotdev/json-compression-in-the-browser-with-gzip-and-the-compression-streams-api-4135
        // Convert text to Stream
        const stream = new Blob([data], { type: 'text/plain' }).stream();
        // gzip stream
        const compressedStream = stream.pipeThrough(new CompressionStream('gzip'));
        // create Response
        const compressedResponse = await new Response(compressedStream);
        // Get response Blob
        const compressedBlob = await compressedResponse.blob();
        // Get the ArrayBuffer
        const buffer = await compressedBlob.arrayBuffer();
        
        // convert ArrayBuffer to base64 encoded string
        const compressedBase64 = btoa(
          String.fromCharCode(
            ...new Uint8Array(buffer)
          )
        );
        
        return compressedBase64;
      }
      
      async function unzipData(compressedBase64) {
        const binaryString = atob(compressedBase64);
        const buffer = new Uint8Array(binaryString.length);
        
        for (let i = 0; i < binaryString.length; i++) {
          buffer[i] = binaryString.charCodeAt(i);
        }
        
        // base64 encoding to Blob
        const stream = new Blob([buffer], { type: 'application/octet-stream' }).stream();
        // piping our data through the gzip DecompressionStream
        const decompressedStream = stream.pipeThrough(new DecompressionStream('gzip'));
        // create Response
        const decompressedResponse = await new Response(decompressedStream);
        // read decompressed stream as blob
        const decompressedBlob = await decompressedResponse.blob();
        // get the content back in string format
        const decompressedData = await decompressedBlob.text();
        
        return decompressedData;
      }

      async function updateHash() {
        let encodedTitle = '';
        let encodedContent = '';
        let isDataZipped = 0;
        
        if (isCompressHashedDataGlobal) {
          try {
            encodedTitle = await zipData(encodeURIComponent(noteTitle.value));
            encodedContent = await zipData(encodeURIComponent(noteContent.value));
            isDataZipped = 1;
          } catch (error) {
            console.warn('Data compression not supported. Storing data unzipped. ', error);
          }
        }
        
        if (!isDataZipped) {
          encodedTitle = btoa(encodeURIComponent(noteTitle.value));
          encodedContent = btoa(encodeURIComponent(noteContent.value));
        }
        
        if (Object.is(uuid, null)) {
          uuid = Math.floor(1*10e12 + Math.random() * 9*10e12);
          renderUUID();
        }
        
        updatedAt = Date.now();
        
        const s = hashDataSeparatorSymbol;
        const isThemeDark = toggle.checked ? 1 : 0;
        const hashSymbol = String.fromCharCode(35);
        const hashData = `${isThemeDark}${s}${isDataZipped}${s}${uuid}${s}${updatedAt}${s}${encodedTitle}${s}${encodedContent}`;

        history.replaceState(undefined, '', hashSymbol + hashData);
        
        renderUpdatedAt();
      }
      
      async function applyHashData() {
        // Get hash data from URL
        const hash = window.location.hash.substring(1);

        if (!hash) {
          return; // No hash data present
        }

        const dataParts = hash.split(hashDataSeparatorSymbol);

        if (dataParts.length !== 6) {
          return; // Invalid hash data format
        }

        // Decode and apply data
        const isThemeDark = parseInt(dataParts[0], 10);
        const isDataZipped = parseInt(dataParts[1], 10);
        uuid = dataParts[2];
        updatedAt = parseInt(dataParts[3], 10);
        let decodedTitle = '';
        let decodedContent = '';
        if (isDataZipped) {
          decodedTitle = await unzipData(dataParts[4]);
          decodedContent = await unzipData(dataParts[5]);
        } else {
          decodedTitle = atob(dataParts[4]);
          decodedContent = atob(dataParts[5]);
        }

        toggle.checked = isThemeDark === 1;
        noteTitle.value = decodeURIComponent(decodedTitle);
        noteContent.value = decodeURIComponent(decodedContent);
        toggle.dispatchEvent(new CustomEvent("change"));
        noteTitle.dispatchEvent(new CustomEvent("input"));
        noteContent.dispatchEvent(new CustomEvent("input"));
        
        renderUUID();
        renderUpdatedAt();
      }
      
      // Variable to store the timeout reference
      let timeoutId = null;
      // debounce function
      function debounce(func, delay) {
        return function (...args) {
          clearTimeout(timeoutId); // Clear any existing timeout
          timeoutId = setTimeout(() => {
            func.apply(this, args); // Call the function with arguments after delay
          }, delay);
        };
      }
      
      // Debounced version with 3s delay
      const debouncedUpdateHash = debounce(updateHash, 3000);
      
      toggle.addEventListener('change', debouncedUpdateHash);
      noteTitle.addEventListener('input', debouncedUpdateHash);
      noteContent.addEventListener('input', debouncedUpdateHash);
      
      // Apply initial data from hash on page load
      applyHashData();
      
      // Set theme based on browser preference (if hash is absent)
      if (!window.location.hash) {
        const prefersDark = matchMedia('(prefers-color-scheme: dark)').matches;
        container.classList.toggle('dark', prefersDark);
        toggle.checked = prefersDark;
      }
    </script>
  </body>
</html>
